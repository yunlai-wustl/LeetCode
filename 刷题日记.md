

# 刷题日记

Target Company:

### 科技公司（Machine Learning， AR/VR）

1. Meta (SWE PhD intern, metauniverse, AR/VR/Machine Learning相关)，
2. Occulus (facebook 中做VR/AR的，不知道是不是分开招聘)
3. Nvidia: （GPU加速，ML相关算法支持）
4. Google,
5. Linkedin，Machine Learning ， 推荐系统， MLE
6. Amazon. SWE，云计算
### 自动驾驶

1. Tesla， 
2. Pony.ai，

### 医疗影像公司

1. 西门子，传统医学影像公司，职位较少，甚至在裁员，但是我们组跟他们有合作
2. 休斯顿联影，实习岗位较少，
3. 芝加哥佳能，传统医学影像公司，
4. Philip，GE信息较少

### 广大互联网公司





## 准备Timeline

2021 秋季学期，刷完前100道，找好ML的项目。做一点C++和cuda的项目；上完CNN（10月）+sequential model（11月上）+cs344 (12月)

2022 春季学期，udemy 的fullstack，争取在投简历前投出ML的会议文章，继续刷题刷到500

2022 夏天开始投简历

刷题timeline：

2月结束cs344第二章；一周一章+作业

3月结束第一遍代码随想录

4-6月刷第二遍（仔仔细细，及时复习回顾，90天，一天至少2道题+回顾）

- 4月
- 5月 继续刷第二遍！！！！！！！！！！！！每天5道题！！！！！！
- 6月

7-8月刷第三遍，开始投简历

8-12月往多里做



- 2月20-28 动态规划 子序列 （12题）+总结
- 3月前两周： 回溯算法（22）+总结
- 3月后两周：位运算（13），
- 3.20-3.26： 数学（14）+搜索
- 3.27-3.31： 图（4），数组和矩阵（12）分治法（2）

# 数据结构相关

## 链表

### 1. 找出两个链表的交点，160，easy

1. 设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。

```c++
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        
        ListNode *nodeA=headA;
        ListNode *nodeB=headB;
        while(nodeA!=nodeB)
        {
            nodeA=(nodeA==nullptr?headB:nodeA->next);
            nodeB=(nodeB==nullptr?headA:nodeB->next);
        }
        return nodeA;
    }
};
```

c++中条件表达式：

```c++
x < 0 ? y = 10 : z = 20;

if (x < 0)
    y = 10；
else
    z = 20;
    
    
a = (x > 100) ? 0 : 1;

if (x > 100)
    a = 0 ;
else
    a = 1;    
   
```

2. Hash Set

   ```c++
   set<ListNode*> visited;
   while(headA!=nullptr)
   {
   	visited.insert(headA);
   	headA=headA->next;
   }
   while(headB!=nullptr)
   {
   	if(visited.count(headB)>0) // if(visited.find(headB)==visited.end())
   		return headB;
   	headB=headB->next;
   }
   return nullptr;	
   ```

   c++ set find an element: set.find(element) == set.end() //set.count>0

### 2. 列表反转，easy，206

递归：

新的结尾就是head->next，即使翻转list之后指针不会变，变的是里面的next

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        if(head==nullptr||head->next==nullptr) return head;
        else 
        {   ListNode* next=head->next;
            ListNode* NewHead=reverseList(next);
            next->next=head;
            head->next=nullptr;
            return NewHead;
        }
    }
};
```



这个有点慢，还可以用头插法：

1. 要记住sorted的list的头部和尾部；尾部的下一个为当前node
2. 记录当前node的下一个；尾部的下一个设为当前node的下一个
3. 把当前的node移到sortedList头部；
4. 更新当前node的next为sortedListHead;
5. 当前node的下一个赋值为当前node

```c++
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* next;
        ListNode* NewHead=head;
        if(head==nullptr||head->next==nullptr) return head;
        while(head->next!=nullptr)
        {   next=head->next;
            head->next=next->next;
            next->next=NewHead;
            NewHead=next;
        }
        return NewHead;
    }
};
```



### 3. Merge 2 sorted list, easy, 21

递归

```c++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1==nullptr) return l2;
        if(l2==nullptr) return l1;
        
        if(l1->val<l2->val)
        {   l1->next=mergeTwoLists(l1->next,l2);
            return l1;
        }
        else {
            l2->next=mergeTwoLists(l1,l2->next);
            return l2;
        }
         
    }
};
```

循环

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
        if(l1==nullptr) return l2;
        if(l2==nullptr) return l1;
        ListNode* head;
        if(l1->val<l2->val)
        {
            head=l1;
            l1=l1->next;
        }   
        else
        {
            head=l2;
            l2=l2->next;
        }
        ListNode* currentNode=head;
        while((l1!= nullptr)&&(l2!=nullptr))
        {
            if(l1->val<l2->val)
            {
                currentNode->next=l1;
                l1=l1->next;
            }
            else
            {
                currentNode->next=l2;
                l2=l2->next;
            }
            currentNode=currentNode->next;
        }
        if(l1==nullptr)
            currentNode->next=l2;
        else
            currentNode->next=l1;
        return head;
    }
    };
```



### 4、删除链表中重复节点（83）

递归

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* tmp=head;
        if(head==nullptr) return head;
        while((tmp!=nullptr)&&(tmp->val==head->val))
            tmp=tmp->next;
        if(tmp==nullptr)
        {   
            head->next=tmp;
            return head;
        }
        head->next=deleteDuplicates(tmp);
        return head;
    }
};
```

```c++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        ListNode* currentNode = head;
        while(currentNode!=nullptr&&currentNode->next!=nullptr)
        {
            if(currentNode->next->val == currentNode->val)
                currentNode->next=currentNode->next->next;
            else
                currentNode=currentNode->next;
        }
        return head;
    }
};
```



### 5. 删除链表的倒数第 n 个节点，19，medium

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* pi=head;
        ListNode* pj=head;
        while(n-->0)
        {
            pi=pi->next;
        }
        if(pi==nullptr) return head->next;
        while(pi->next!=nullptr)
        {
            pj=pj->next;
            pi=pi->next;
        }
            
        pj->next=pj->next->next;
        return head;
    }
};
```

类似于双指针的思想，不过保持两者之间距离固定，让一个指针先跑到最后。

### 6. 交换相邻的一对Node, 24

递归；

先把一对后面的那个存为tmp；

然后n2->next定义为n1;

n1->next定义为swapPairs(tmp)

如果tmp是null或者tmp->next是null, 返回tmp。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* newHead=head->next;
        head->next=swapPairs(head->next->next);
        newHead->next=head;
      return newHead;
}   
};
```

Iterative 

```c++
class Solution {
public:
    ListNode* swapPairs(ListNode* head) {

        ListNode* currentNode = head;
        ListNode* tmp;
        ListNode* tail;
        if(head==nullptr||head->next==nullptr) return head;
        ListNode* newHead=head->next;
        while(currentNode!=nullptr && currentNode->next!=nullptr)
        {   
            tmp=currentNode->next;

            if(currentNode!=head)
                tail->next=tmp;
            tail = currentNode;
            currentNode->next=tmp->next;
            tmp->next=currentNode;
            currentNode=currentNode->next;
        }
        return newHead;
    }   
};
```



### 7. 链表求和，medium，445

先反转两个链表，再相加，再反转。

reverse list 一定要背过

因为位数太多，没办法转换成整数。

会stack后再回来看这个。

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* reverseL1 = reverseList(l1);
        ListNode* reverseL2 = reverseList(l2);
        ListNode* head =nullptr;
        int carry = 0;
        while(reverseL1!=nullptr || reverseL2!=nullptr)
        {
            int x1 = (reverseL1==nullptr? 0:reverseL1->val);
            int x2 = (reverseL2==nullptr? 0:reverseL2->val);
            
            ListNode* curr=new ListNode((carry+x1+x2)%10);
            carry = (carry+x1+x2)/10;
            curr->next=head;
            head = curr;
            if(reverseL1!=nullptr)
                reverseL1=reverseL1->next;
            if(reverseL2!=nullptr)
                reverseL2=reverseL2->next;
        }
        if(carry!=0)
        {
            ListNode* curr=new ListNode(carry);
            curr->next=head;
            head = curr;
        }
        return head;
 
    }
    ListNode* reverseList(ListNode *head)
    {
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* newTail=head->next;
        ListNode* newHead = reverseList(head->next);
        newTail->next=head;
        head->next=nullptr;
        return newHead;
    }
};
```

用stack

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* reverseL1 = reverseList(l1);
        ListNode* reverseL2 = reverseList(l2);
        ListNode* head =nullptr;
        int carry = 0;
        while(reverseL1!=nullptr || reverseL2!=nullptr)
        {
            int x1 = (reverseL1==nullptr? 0:reverseL1->val);
            int x2 = (reverseL2==nullptr? 0:reverseL2->val);
            
            ListNode* curr=new ListNode((carry+x1+x2)%10);
            carry = (carry+x1+x2)/10;
            curr->next=head;
            head = curr;
            if(reverseL1!=nullptr)
                reverseL1=reverseL1->next;
            if(reverseL2!=nullptr)
                reverseL2=reverseL2->next;
        }
        if(carry!=0)
        {
            ListNode* curr=new ListNode(carry);
            curr->next=head;
            head = curr;
        }
        return head;
 
    }
    ListNode* reverseList(ListNode *head)
    {
        if(head==nullptr||head->next==nullptr)
            return head;
        ListNode* newTail=head->next;
        ListNode* newHead = reverseList(head->next);
        newTail->next=head;
        head->next=nullptr;
        return newHead;
    }
};
```



### 8. 判断回文序列, 234,easy

利用指针反转会改变原始list

所以反转后半段然后对比

指针到中间：一个指针是另一个指针的两倍，快指针到达list end，慢指针就在list中间

```c++
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if(head==nullptr||head->next==nullptr) return true;      

        ListNode* f=head;
        ListNode* s=head;
        while((f!=nullptr)&&(f->next!=nullptr))
        {
            f=f->next->next;
            s=s->next;
        }
        if(f!=nullptr)
            s=s->next;
        ListNode* rs=reverseList(s);
        while(rs!=nullptr)
        {
            if(rs->val!=head->val)
                return false;
            rs=rs->next;
            head=head->next;
        }
        return true;
    }
    ListNode* reverseList(ListNode* head)
    {
        if(head==nullptr||head->next==nullptr) return head;
        ListNode* next=head->next;
        ListNode* NewHead=reverseList(next);
        next->next=head;
        head->next=nullptr;
        return NewHead;
    }
};
```

### 9.Split Linked List in Parts, 725, medium

题目描述：把链表分隔成 k 部分，每部分的长度都应该尽可能相同(相差不超过1)，排在前面的长度应该大于等于后面的。

c++ vector:

```c++
vector<int> v(5);  //vector containing 5 elements
v[i] //access ith element
```



```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    vector<ListNode*> splitListToParts(ListNode* head, int k) {
        // get length of linked list
        ListNode* tmp = head;
        vector<ListNode*> v(k);
        int l_list=0;
        while(tmp!=nullptr)
        {
            tmp=tmp->next;
            l_list++;
        }
        int l_sublist = l_list/k;
        int n_longlist = l_list%k;
        ListNode* cur = head;
        for(int i=0;i<k;i++)
        {
            v[i]=cur;
            if(i==k-1)
                break;
            for(int j=0;j<l_sublist-1+(i<n_longlist);j++)
            {
                if(cur!=nullptr)
                    cur=cur->next;
            }
            if(cur!=nullptr)
            {
                ListNode* prev=cur;
                cur=cur->next;
                prev->next=nullptr;
            }
        }
        return v;
    }
};
```

### 10. Odd Even Linked List (328, Medium)

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if(head==nullptr||head->next==nullptr) return head;
        ListNode* odd_end=head;
        ListNode* even_end=head->next;
        ListNode* even_start=head->next;
        ListNode* next;
        int i=2;
        while(even_end->next!=nullptr)
        {   
            if(i%2==1)
            {
                i++;
                even_end=even_end->next;
            }
            else
            {
                next=even_end->next;
                even_end->next=next->next;
                odd_end->next=next;
                odd_end=next;
                odd_end->next=even_start;
                i++;
            }
            
        }
        return head;
        
    }
};
```



## 树

### 递归

总是不懂的: 437, 687

### 1. 树的depth, 104, easy

```c++
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if(root==nullptr)
            return 0;
        return 1+max(maxDepth(root->left),maxDepth(root->right));

    }
};
```

### 2. 判断平衡树,110,easy

加了helper function（计算depth）

递归出现一次就行，多了time就差了

```
class Solution {
private:
    bool result = true;

public:
    bool isBalanced(TreeNode* root) {
        if(root==nullptr) return true;
        return isBalanced(root->left)&&isBalanced(root->right)&&(abs(MaxDepth(root->left)-MaxDepth(root->right))<2);
    }
    int MaxDepth(TreeNode* root)
    {
        if(root==nullptr) return -1;
        return(1+max(MaxDepth(root->left),MaxDepth(root->right)));
    }

};
```

### 3. 两节点的最长路径，543， easy

```c++
class Solution {
public:
    int diameterOfBinaryTree(TreeNode* root) 
    {  
        if(root==nullptr) return 0;
        return max(max(diameterOfBinaryTree(root->left),diameterOfBinaryTree(root->right)),\
                   MaxDepth(root->left)+MaxDepth(root->right)+2);
    }
    int MaxDepth(TreeNode* root)
    {
        if(root==nullptr) return -1;
        int l = MaxDepth(root->left);
        int r = MaxDepth(root->right);
        return max(l,r)+1;
    }
};
```

### 4. 翻转树，226，easy

```
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(root==nullptr) return nullptr;
        TreeNode *tmp=root->right;
        root->right=invertTree(root->left);
        root->left=invertTree(tmp);
        return root;
    }
};
```

### 5. Merge 2 Binary Trees, 617, easy

注意递归的base；以及从哪开始递归（root to leaf？ leaf to root?）

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
        if((root1==nullptr)&&(root2==nullptr)) return nullptr;
        else if(root1==nullptr) return root2;
        else if(root2==nullptr) return root1;
        else 
        {
            TreeNode *newroot;
            newroot=new TreeNode(root1->val+root2->val,mergeTrees(root1->left,root2->left),mergeTrees(root1->right,root2->right));
            return newroot;
        }
    }
};
```

### 6. Path Sum, 112

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(root==nullptr) return false;
        if(root->left==nullptr&root->right==nullptr) return targetSum==root->val;
        return (hasPathSum(root->left,targetSum-root->val)||hasPathSum(root->right,targetSum-root->val));
    }
};
```

### 7. 统计路径和等于一个数的路径数量 437. Path Sum III (Easy)

prefix sum (记录到一个hash map中)

```c++
class Solution {
public:
    int target;
    unordered_map<int,int> prefix;
    int ret = 0;
    int pathSum(TreeNode* root, int targetSum) {
        target = targetSum;
        preorder(root, 0);
        return ret;
    }
    void preorder(TreeNode *node, int cur)
    {
        if(node == nullptr) return;
        cur+=node->val;
        prefix[cur]++;
        ret+= (cur==target)+(prefix.find(cur-target)!=prefix.end()? prefix[cur-target]:0);
        preorder(node->left,cur);
        preorder(node->right,cur);
        prefix[cur]--;
    }
};
```

### 8. 572, easy, Subtree of Another Tree

```c++
class Solution {
public:
    bool isSubtree(TreeNode* root, TreeNode* subRoot) {
        if(root==nullptr) return (subRoot==nullptr);
        return isSubtreeWithRoot(root,subRoot)||isSubtree(root->left,subRoot)||isSubtree(root->right,subRoot);
    }
    bool isSubtreeWithRoot(TreeNode* root, TreeNode* subRoot)
    {
        if(root==nullptr&&subRoot==nullptr) return true;
        if(root==nullptr&&subRoot!=nullptr || root!=nullptr&&subRoot==nullptr) return false;
        if(root->val==subRoot->val)
            return (isSubtreeWithRoot(root->left,subRoot->left)&isSubtreeWithRoot(root->right,subRoot->right));
        else
            return false;
    }
};
```

### 9. 101, easy,Symmetric Tree

```c++
class Solution {
public:
    bool isSymmetric(TreeNode* root) {
        if(root==nullptr) return true;
        return isMirror(root->left,root->right);
    }
    bool isMirror(TreeNode* root1,TreeNode* root2)
    {
        if(root1==nullptr)
            return (root2==nullptr? true:false);
        if(root2==nullptr)
            return false;
        return (root1->val==root2->val)&&isMirror(root1->left,root2->right)&&isMirror(root1->right,root2->left);
        
    }
};
```

### 10. 111, easy, Minimum Depth of Binary Tree

```
class Solution {
public:
    int minDepth(TreeNode* root) {
        if(root==nullptr) return 0;
        if(root->left==nullptr||root->right==nullptr)
            return 1+minDepth(root->left)+minDepth(root->right);
        else    
            return 1+min(minDepth(root->left),minDepth(root->right));
   }
};
```

### 11. 统计左叶子节点的和 Sum of Left Leaves (Easy)

```c++
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if(root==nullptr) return 0;
        return (isleaf(root->left)?root->left->val:0)+sumOfLeftLeaves(root->right)+sumOfLeftLeaves(root->left);
    }
    bool isleaf(TreeNode* root)
    {
        if(root==nullptr) return false;
        return (root->left==nullptr)&&(root->right==nullptr);
    }
};
```

### 12. Medium, 437. Path Sum III

1. 递归，写一个helper function判断是否有以当前Node为root的path

   time complexity: O(n^2), space complexity: O(n)

```c++
class Solution {
public:

    int pathSum(TreeNode* root, int targetSum) {
        int S=0;
        if(root==nullptr) return 0;
        return PathWithNode(root,targetSum)+pathSum(root->left,targetSum)+pathSum(root->right, targetSum);

    }
    int PathWithNode(TreeNode* root, int left)
    {
        if(root==nullptr)
            return 0;
        left-=root->val;
        return (left==0? 1:0) + PathWithNode(root->left, left) + PathWithNode(root->right,left);

    }
};
```

2. Running prefix sum

   ```c++
   public:
   	int pathSum(TreeNode* root, int targetSum)
       {
           ans_ = 0; //number of paths with sum = target
           sums_={{0,1}}; //hash map storing prefix sum
           pathSum(root, 0, targetSum);
           return ans_;
       }
   private:
   	int ans_;
   	unordered_map<int,int> sums_;
   	void pathSum(TreeNode* root, int cur, int sum)
       {
           if(!root) return;
           cur+=root->val;
           ans_+=sums[cur-sum]
           sums_[cur]++;
           pathSum(root->left,cur,sum);
           pathSum(root->right,cur,sum);
           sums_cur[cur]--
       }
   ```

   https://www.cnblogs.com/grandyang/p/6007336.html

### 13. medium, 687. Longest Univalue Path

递归函数返回的是**以当前Node为根节点**的最大path

```c++
class Solution {
public:
    int longestUnivaluePath(TreeNode* root) {
    int res=0;
    helper(root, res);
    return res;
    }
    int helper(TreeNode* root, int& res)
    {
        if(!root) return 0;
        int left = helper(root->left,res);
        int right = helper(root->right,res);
        left= (root->left!=nullptr && root->left->val==root->val? left+1:0);
        right= (root->right!=nullptr && root->right->val==root->val? right+1:0);
        res = max(res,left+right);
        return max(left,right);
    }
};
```

```c++
class Solution {
public:
    int longestUnivaluePath(TreeNode* root) {
        if (!root) return 0;
        int sub = max(longestUnivaluePath(root->left), longestUnivaluePath(root->right));
        return max(sub, longestUnivaluePathRoot(root->left, root->val) + longestUnivaluePathRoot(root->right, root->val));
    }
    int longestUnivaluePathRoot(TreeNode* node, int parent) {// return longest path with current node as root
        if (!node || node->val != parent) return 0;
        return 1 + max(helper(node->left, node->val), helper(node->right, node->val));
    }
};
```

### 14. 671, Second Minimum Node In a Binary Tree (Easy)

set: s.begin; s.++

Internally, [set](https://www.cplusplus.com/set) containers keep all their elements sorted

```c++
class Solution {
public:
    set<int> s;
    int findSecondMinimumValue(TreeNode* root) {
        dfs(root);
        if(s.size()==1) return -1;
        auto it=s.begin();
        it++;
        return (*it);
    }
    void dfs(TreeNode* root)
    {   
        if(root==nullptr) return;
        s.insert(root->val);
        dfs(root->left);
        dfs(root->right);
        return;
    }
};
```

### 15. 337. House Robber III

递归：比较gradparents + 4 gradchilder VS 2 children

```c++
class Solution {
public:
    int rob(TreeNode* root) {
        int l=0;
        int r=0;
        return helper(root,l,r);
    }
 private:
    int helper(TreeNode* root, int& l, int& r)
    {
        if(root==nullptr) return 0;
        int ll=0;
        int lr=0;
        int rl=0;
        int rr=0;
        l=helper(root->left,ll,lr);
        r=helper(root->right,rl,rr);
        return max(ll+lr+rr+rl+root->val,l+r);
    }
};
```





### BST

### 1. 修剪二叉查找树

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* trimBST(TreeNode* root, int low, int high) {
        if(root==nullptr) return root;
        if(root->val > high) return trimBST(root->left,low,high);
        if(root->val < low) return trimBST(root->right,low,high);
        root->left=trimBST(root->left,low,high);
        root->right=trimBST(root->right,low,high);
        return root;
    }
};
```

### 2.寻找二叉查找树中的第k个元素

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int kthSmallest(TreeNode* root, int k) {
        int n=count(root->left);
        if(n==k-1) return root->val;
        if(n<k-1) return(kthSmallest(root->right,k-1-n));
        return (kthSmallest(root->left,k));
            
                
        
    }
private:
    int count(TreeNode* node)
    {
        if(node==nullptr) return 0;
        return (1+count(node->left)+count(node->right));
    }
};
```

### 538 

## 栈和队列

### C++中的stack和deque容器

##  

### 1. 用stack实现队列, 232. easy

stack：first in last out （FILO）, queue: first in first out.

用2个stack，一个in,一个out来实现队列。

注意：pop返回值是void

```c++
class MyQueue {
public:
    MyQueue() {

    }
    stack<int> s_in;
    stack<int> s_out;
    
    void push(int x) {
        s_in.push(x);
    }
    
    int pop() {
        in2out();
        int top=peek();
        s_out.pop();
        return (top);
    }
    
    int peek() {
        in2out();
        return s_out.top();
    }
    
    bool empty() {
        return ((s_in.empty())&&(s_out.empty()));
    }
    void in2out()
    {   if(s_out.empty())
        {while(!s_in.empty())
        {
            s_out.push(s_in.top());
            s_in.pop();
        }
    }}
};

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue* obj = new MyQueue();
 * obj->push(x);
 * int param_2 = obj->pop();
 * int param_3 = obj->peek();
 * bool param_4 = obj->empty();
 */
```

### 3. 最小值栈 Min Stack (155，Easy)

```c++
class MinStack {
public:
    
    MinStack() {
    
    }
    stack<int> smin;
    stack<int> st;

    
    void push(int val) {
        if((smin.empty())||(val<=smin.top()))
            smin.push(val);
        st.push(val);
    }
    
    void pop() {
        if(st.top()==smin.top())
            smin.pop();
        st.pop();
    }
    
    int top() {
        return st.top();
    }
    
    int getMin() {
        if(smin.empty()) return -1;
        else
            return smin.top();
    }

};

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack* obj = new MinStack();
 * obj->push(val);
 * obj->pop();
 * int param_3 = obj->top();
 * int param_4 = obj->getMin();
 */
```



## 数组和矩阵

Note: index循环条件： always check if i is out-of-bound

### 1. Move Zeroes, 283 easy

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int i_1st0 = 0;
        int length = nums.size();
        while((i_1st0<length)&&(nums[i_1st0]!=0))
        {
            i_1st0++;
        }
        int i_curr = i_1st0+1;

        while(i_curr<length)
        {
            if(nums[i_curr]==0)
            {
                i_curr++;
                continue;
            }
            else
            {
                swapNum(i_1st0,i_curr,nums);
                i_1st0++;
                i_curr++;
            }
        }
    }
    void swapNum(int i, int j,vector<int>& nums)
    {
        int tmp=nums[i];
        nums[i]=nums[j];
        nums[j]=tmp;
    }
};
```

```c++
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
    int length = nums.size();
    int i=0;
    int i0=0;
    while(i<length)
    {
        if(nums[i]!=0)
        {
            nums[i0]=nums[i];
            i0++;
        }
        i++;
    }
    while(i0<length)
    {
        nums[i0]=0;
        i0++;
    }
    }
};
```

### 2. reshape矩阵

```c++
class Solution {
public:
    vector<vector<int>> matrixReshape(vector<vector<int>>& mat, int r, int c) {
        vector<vector<int>> op(r, vector<int>(c));
        int m = mat.size(), n = mat[0].size();
        if(r*c != m*n) return mat;
        int x = 0, y = 0;
        for(auto i: mat)
            for(auto j: i){
                op[x][y++] = j;
                if(y == c) y=0, x++;
            }
        return op;
    }
};

```

### 3. 找到最长连续为1, 485. Max Consecutive Ones (Easy)

```c++
class Solution {
public:
    int findMaxConsecutiveOnes(vector<int>& nums) {
        int max_num=0;
        int l1=0;
        for(auto n:nums)
        {
            if(n==1)
            {   
                if(++l1>max_num)
                    max_num=l1;
            }
            else
            {   
                l1=0;
            }
        }
        return max_num;
    }
};
```

### 4. 有序2D矩阵查找。240， medium

Search space reduction.
Start from the left bottom. 
If target is larger than current element, then all the right elements in same row is larger than target. So go up.
If target is smaller than current element, then so do all upper elements on same column. Move pointer to right. 

```c++
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
     
        int row = matrix.size();
        int col = matrix[0].size();
        int j=col-1;
        int i=0;
        while((i<row)&&(j>=0))
        {
            if(matrix[i][j]<target)
                i++;
            else if(matrix[i][j]==target)
                return true;
            else
                j--;
        }
        return false;

}
};
```

### 5  有序矩阵的 Kth Element

https://www.youtube.com/watch?v=JJUv4DDLSB4
二分法，需要掌握的点

1. 一定收敛到矩阵所含有的元素，因为是找大于等于某数的最小值，区间在不断减小。即使是已经找到满足条件的 countEqualOrSmaller(matrix,mid)>=k, higher 也会减小
2. 怎么在排好序的二维矩阵中O（n）找到对应元素:
   - 从左下或者右上角出发
   - count每次需要加的就是行数，即为那一列比target小的数

```c++
class Solution {
public:
    int kthSmallest(vector<vector<int>>& matrix, int k) {
        long lower=INT_MIN; 
        long higher=INT_MAX;
        int mid;
        while(lower<higher)
        {
            mid = lower+(higher-lower)/2;
            if(countEqualOrSmaller(matrix,mid)<k)
                lower=mid+1;
            else //countEqualOrSmaller(matrix,mid)>=k
                higher=mid;
        }
        return lower;
    }
    int countEqualOrSmaller(vector<vector<int>>& matrix,int target)
    {
        int n=matrix.size();
        int i=n-1, j=0,count=0;
        while(i>=0&j<n)
        {
            if(matrix[i][j]>target)
            {
                i--;
            }
            else
            {
                count += i+1 ;
                j++;
            }
        }
        return count;
    }
};
```

### 6 645,easy 一个数组元素在 [1, n] 之间，其中一个数被替换为另一个数，找出重复的数和丢失的数

```c++
class Solution {
public:
    vector<int> findErrorNums(vector<int>& nums) {
        vector<bool> seen(nums.size()+1);
        int repeat;
        int loss;
        for(int i=0;i<nums.size();i++)
        {
            if(seen[nums[i]]==true)
            {
                repeat = nums[i];
            }
            seen[nums[i]]=true;
        }
        for(int i=1;i<seen.size();i++)
        {
            if(seen[i]!=true)
            {
                loss = i;
                break;
            }    
            
        }
        vector<int> res;
        res.push_back(repeat);
        res.push_back(loss);
        return res;

        

    }

};
```


## 哈希表

### 2.  判断数组是否含有重复元素

- unordered_map 初始化：看样子默认值是0

```c++
class Solution {
public:
    bool containsDuplicate(vector<int>& nums) {
 		unordered_map mp<int,int>;
        for(int i:nums)
        {
            if(++mp[i]>1)
                return true;
        }
        return false;
    }
}
```

### 3.  easy, 594. Longest Harmonious Subsequence

```c++
class Solution {
public:
    int findLHS(vector<int>& nums) {
        unordered_map<int,int> mp;
        int res=0;
        for(int i:nums)
        {
            mp[i]++;
            if(mp.count(i+1))
                res=max(res,mp[i]+mp[i+1]);
            if(mp.count(i-1))
                res=max(res,mp[i]+mp[i-1]);            
        }
        return res;
        
    }
};
```



## 字符串

### 1. 字符串循环移位包含，编程之美3.1

```
s1 = AABCD, s2 = CDAA
Return : true
```

给定两个字符串 s1 和 s2，要求判定 s2 是否能够被 s1 做循环移位得到的字符串包含。

s1 进行循环移位的结果是 s1s1 的子字符串，因此只要判断 s2 是否是 s1s1 的子字符串即可。

```c++
string s1s1=s1.append(s1);
return s1.find(s2)!=-1;
```

### 2



[编程之美 2.17](https://github.com/CyC2018/CS-Notes/blob/master/notes/Leetcode 题解 - 字符串.md#)

```
s = "abcd123" k = 3
Return "123abcd"
```

将字符串向右循环移动 k 位。

构建ss：注意append会改变原字符串

```
    string s = "abcd123";
    int k = 3;
    string ss = string(s);
    ss.append(s);
    string subss = ss.substr(s.length()-k,s.length());
    cout<<subss<<endl;
```

### 4. 回文字符串 680. Valid Palindrome II (Easy)

```c++
class Solution {
public:
    bool isAnagram(string s, string t) {
        std::map<char,int> map;
        if(s.length()!=t.length()) return false;
        for(int i=0;i<s.length();i++)
        {
            map[s[i]]++;
            map[t[i]]--;
        }
        for(auto p:map)
        {
            if(p.second!=0)
                return false;
        }
        return true;
    }
};
```

### 5. 归并两个有序数组, Merge Sorted Array (Easy)

C++ stl 有sort function .

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        
        for(int i=m;i<m+n;i++)  
            nums1[i]=nums2[i-m];
        sort(nums1.begin(), nums1.end());
        }
};
```

### 6.easy, 141. Linked List Cycle

```c++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        map<ListNode*,int> m;
        int i=0;
        while(head!=nullptr)
        {
            if(m.find(head)==m.end())
            {
                m[head]=i;
                i++;
            }
            else 
                return true;
            head=head->next;
        }
        return false;
    }
};
```

快慢指针: Floyd's Tortoise and Hare

- L1: the distance from head to start node of cycle
- L2: the distance from start node of cycle to crossing node of two pointers
- L3: the distance from crossing node of two pointers to start node of cycle

Slow pointer to crossing node is L1+L2.

Fast pointer to crossing node is 2(L1+L2) since fast pointer always move 2 times of slow pointer step.

Fast pointer is also equal to L1+L2+L3+L2 because to meet with slow pointer, the fast pointer has to run over cycle at least 1 time.

Therefor ***2(L1+L2)=L1+L2+L3+L2 -> 2L1=L1+L3 -> L1 = L3***

```c++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* pf=head;
        ListNode* ps=head;
        while(pf!=nullptr&&pf->next!=nullptr)
        {
            pf=pf->next->next;
            ps=ps->next;
            if(ps==pf)
                break;
        }
        if(pf==nullptr||pf->next==nullptr) return nullptr;
        ListNode* pss = head;
        while(pss!=pf)
        {
            pf=pf->next;
            pss=pss->next;
        }
        return pf;
    }
};
```

### 409. Longest Palindrome Easy

用hashmap存储每个charactor出现多少次

然后把值相加；若值为奇数，则-1，并设置flag为true；

flag是TRUE的话，最后输出result+1； 否则输出result。

```c++
class Solution {
public:
    int longestPalindrome(string s) {
        map<char,int> m;
        int res=0;
        for(auto c:s)
        {
            m[c]++;
        }
        bool flag=false;
        for(auto cc:m)
        {
            res += cc.second;
            if(cc.second%2>0)
            {
                res--;
                flag=true;
            }
        }
        return (flag? res+1:res);
    }
};
```



# 算法相关

## 双指针

总结：一般是有两种，同向双指针或是逆向双指针。

同向双指针适用于需要位置保持不变的，比如ordered array

### 1. 有序数组的Two sum, 167, easy

题目描述：在有序数组中找出两个数，使它们的和为 target

```
Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
```

一开始我用同向指针，但是时间复杂度太高 O(n^2)。逆向指针的时间复杂度就是O（n）.

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int i=0;
        int j=numbers.size()-1;
        vector<int> result;
        while(i<j)
        {
            if(numbers[i]+numbers[j]==target)
            {
                result.push_back(i+1);
                result.push_back(j+1);
                return result;        
            }
            else if(numbers[i]+numbers[j]<target)
                i++;
            else if(numbers[i]+numbers[j]>target)
                j--;
        }
        return result;
    }
};
```



 ### 2.平方和

注意i是从0开始的；j 如果从c开始会报错？

i,j square Sum 都为long时，比较起来会快？

如果i, j都是int，平方和为int，跟long比较会慢？

```c++
class Solution {
public:
    bool judgeSquareSum(int c) {
        long int i=0;
        long int j=sqrt(c);
        long int squareSum;
        while(i<=j)
        {   squareSum=i*i+j*j;
            if(squareSum==c)    return true;
            else if(squareSum<c) i++;
            else  j--;c++
        }
        
        
        return false;
    }
};
```

### 3. 345,  Reverse Vowels of a String (Easy)

别忘了交换后 i++和 j-- 

```c++
class Solution {
public:
    string reverseVowels(string s) {
        
        int i=0;
        int size=s.length();
        int j=size-1;
        char tmp;
        while(i<j)
        {
            while((i<size)&&((s[i]!='a')&&(s[i]!='e')&&(s[i]!='i')&&s[i]!='o'&&s[i]!='u'\
                 &&(s[i]!='A')&&(s[i]!='E')&&(s[i]!='I')&&s[i]!='O'&&s[i]!='U'))
                i++;
            while((j>0)&&((s[j]!='a')&&(s[j]!='e')&&(s[j]!='i')&&s[j]!='o'&&s[j]!='u'\
                  &&(s[j]!='A')&&(s[j]!='E')&&(s[j]!='I')&&s[j]!='O'&&s[j]!='U'))
                j--;
            if(i>=j) return s;
            tmp=s[i];
            s[i]=s[j];
            s[j]=tmp; 
            i++;
            j--;
        }
        return s;
    }
};
```

### 4. 回文字符串 680 Valid Palindrome II (Easy)

```c++
class Solution {
public:
    bool validPalindrome(string s) {
        int n_delete=0;
        int slow=0;
        int fast=s.length()-1;
        while(slow<fast)
        {
            if(s[slow]!=s[fast])
            {
                return isValid(s,slow+1,fast)||isValid(s,slow,fast-1);
            }
            else
            {
                slow++;
                fast--;
            }
        }
        return true;
}
    bool isValid(string s,int i,int j)
    {   while(i<j)
        {
            if(s[i]!=s[j])
                return false;
            i++;
            j--;
        }
    return true;
    }
};
```

### 5. Merge Sorted Array, easy,88

双指针，从尾部开始

```c++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {        

        int i1=m-1;
        int i2=n-1;
        for(int j=m+n-1;j>=0;j--)
        {
            if(i2<0)
                break;
            else
                if(i1>=0 && nums2[i2]<nums1[i1])
                    nums1[j]=nums1[i1--];
                else
                nums1[j]=nums2[i2--];                
        }
        return;
    }
    };
```

### 6. 141 easy linked list cycle

1: hash map; use node as key

2: Floyd's Cycle Finding Algorithm

```c++
 */
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(head==nullptr||head->next==nullptr) return false;
        ListNode* slow=head;
        ListNode* fast=head->next;
        while(fast!=nullptr && fast->next!=nullptr)
        {
            if(slow==fast) return true;
            else{
                slow=slow->next;
                fast=fast->next->next;
            }
        }
        return false;
    }
};
```

### 7. 最长子序列

```c++
class Solution {
public:
    string findLongestWord(string s, vector<string>& dictionary) {
        int MaxLength=0;
        int ind = -1;
        for(int i=0;i<dictionary.size();i++)
        {
            int l=matchString(s,dictionary[i]);
            if(l>MaxLength)
            {
                ind = i;
                MaxLength=l;
            }
            else if(l==MaxLength&&dictionary[i]<dictionary[ind])
                ind=i;
        }
        return (ind==-1? "":dictionary[ind]);
    }
    
    int matchString(string l,string s){
        int il=0;
        int is=0;
        while(il<l.length()&&is<s.length())
        {
            if(l[il]==s[is]){
                is++;
            }
                il++;
        }
        if(is==s.length()) return is;
        else return -1;
        
    }
};
```



## 二分查找

```
BinarySearch(numbers, numbersSize, key) {
   mid = 0
   low = 0
   high = numbersSize - 1
   
   while (high >= low) {
      mid = (high + low) / 2
      if (numbers[mid] < key) {
         low = mid + 1
      }
      else if (numbers[mid] > key) {
         high = mid - 1
      }
      else {
         return mid
      }
   }
   
   return -1 // not found
}
```



### 1. Leetcode 69, 平方根

```c++
class Solution {
public:
    int mySqrt(int x) {
        if(x<=1)
        {    
            return x;
        }
        else
        {
        unsigned int mid = 0;
        unsigned int low = 1;
        unsigned int high = x;
        unsigned int sqrt;
        while (high>=low)
        {   mid = (high+low)/2;
            sqrt = x/mid;
         if(sqrt==mid)
             return mid;
         else if(mid>sqrt)
            high=mid-1;
         else
            low=mid+1;

        }
            return high;

        }
}
};
```

recursive 做法：

### 2. 544, 大于给定元素的最小元素

```c++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {
        int low=0;
        int high=letters.size()-1;
        int mid;
        while(low<=high)
        {
            mid=(low+high)/2;
            if(letters[mid]<=target)
                low=mid+1;
            else 
                high=mid-1;
            
        }
        return low<letters.size()? letters[low]:letters[0];
    }
};

```

Since it is already sorted, can use linear Search:

```c++
class Solution {
public:
    char nextGreatestLetter(vector<char>& letters, char target) {

        for(int i=0;i<letters.size();i++)
        {
            if(letters[i]>target)
                return letters[i];
        }
        return letters[0];
    }
};
```



### 3. 540 有序数组的single element

一个有序数组只有一个数不出现两次，找出这个数。

mid一定要是奇数位；

确定是high还是low +2

```c++
class Solution {
public:
    int singleNonDuplicate(vector<int>& nums) {
        int low=0;
        int s=nums.size();
        int high=s-1;
        int mid;
        while(low<high)
        {
            int mid=(low+high)/2;
            if(mid%2) mid--;

            if(nums[mid+1]==nums[mid])
               low=mid+2;
            else 
                high=mid;
        }
        return(nums[low]);
    }
};
```



### 4. 278, First Bad Version (Easy)

```c++
class Solution {
public:
    int firstBadVersion(int n) {
        int low=0;
        int high=n;
        int mid;
        while(low<high)
        {
            mid=low+(high-low)/2;
            if(isBadVersion(mid))
                high=mid;
            else
                low=mid+1;
        }
        return low;
    }
};
```

### 5.  Find Minimum in Rotated Sorted Array, 153, medium

中间比最后的小：说明在中间跟low之间，mid可能是最小值，high=mid；

中间比最后值大：说明最小值在中间跟high之间，mid不可能是最小值，low=mid+1

```c++
class Solution {
public:
    int findMin(vector<int>& nums) {
        int low=0;
        int high=nums.size()-1;
        int mid;
        while(low<high)
        {
            mid=low+(high-low)/2;
            if(nums[mid]<nums[high])
            {
                high=mid;
            }
            else
                low=mid+1;
        }
        return nums[low];
    }
};
```

### 6. Find First and Last Position of Element in Sorted Array, 34, medium

找到第一个就可以了，然后往前和往后找到第一、最后一个

```c++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        vector<int> result;
        int l=0;
        int h=nums.size()-1;
        int m=(l+h)/2;
        if((h<0)||((h==0)&&(nums[0]!=target))) 
        {
            result.push_back(-1);
            result.push_back(-1);
            return (result);
        }
        if((h==0)&&(nums[0]==target))
        {
            result.push_back(0);
            result.push_back(0);
            return result;
        }
        //find 1st
        while(h>=l)
        {
            m=(l+h)/2;
            if(nums[m]<target)
                l=m+1;
            else if (nums[m] > target) {
                h = m-1;
            }
            else break;
        }
        

        if(nums[m]!=target)
        {
            result.push_back(-1);
            result.push_back(-1);

        }
        else
        {
            while((m>=0)&&(nums[m]==target))
               m--;
            m=m+1;
            result.push_back(m);
            while((m<nums.size())&&(nums[m]==target))
                m++;     
            m=m-1;
            result.push_back(m);
        }
        return result;       
        
    }
};
```

## 回溯算法

回溯法三部曲

- 递归函数的返回值以及参数
- 回溯函数终止条件
- 单层搜索的过程

```
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```



### 1. 70 combination

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

递归+回溯

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<vector<int>> combine(int n, int k) {
        backtrack(1,n,k);
        return result;
    }
    void backtrack(int startIndex, int n,int k)
    {
        if(path.size()==k)
        {
            result.push_back(path);
            return;
        }
        for(int i=startIndex;i<=n;i++)
        {
            path.push_back(i); //处理节点
            backtrack(i+1,n,k); //递归
            path.pop_back();   //回溯，撤销处理的节点
        }
    }
};
```

### 2. 17 电话号码字符组合

和前面的十分相似

```c++
class Solution {
public:
    vector<string> result;
    string s;
    const string letterMap[10] = {
    "", // 0
    "", // 1
    "abc", // 2
    "def", // 3
    "ghi", // 4
    "jkl", // 5
    "mno", // 6
    "pqrs", // 7
    "tuv", // 8
    "wxyz", // 9
    };    
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0) return result;
        backtrack(0,digits);
        return result;
    }
    void backtrack(int index,string digits)
    {
        if(s.size()==digits.size())
        {
            result.push_back(s);
            return;
        }
        string s_tmp=letterMap[digits[index]-'0'];
        for(int i=0;i<s_tmp.size();i++)
        {
            s.push_back(s_tmp[i]);
            backtrack(index+1,digits);
            s.pop_back();
        }
    }
};
```

### 3. 39 组合总和

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> com;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtrack(candidates, target,0);
        return result;
    }
class Solution {
public:
    vector<vector<int>> result;
    vector<int> com;
    vector<vector<int>> combinationSum(vector<int>& candidates, int target) {
        backtrack(candidates, target,0);
        return result;
    }
    void backtrack(vector<int>& candidates, int target, int start_index)
    {
        if(sum(com)==target)
        {
            result.push_back(com);
            return;
         }
        if(sum(com)>target)
            return;

        for(int i=start_index;i<candidates.size();i++)
        {
            com.push_back(candidates[i]);
            backtrack(candidates,target,i);
            com.pop_back();
        }
        
    }
    int sum(vector<int>& candidates)
    {
        int s=0;
        for(int i:candidates)
            s += i;
        return s;
    }
};
};
```

### 4. 40组合总和||

搞清楚同层、同枝

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> com;
    vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {
        vector<bool> used(candidates.size(),false);
        sort(candidates.begin(),candidates.end());
        backtrack(candidates, target, 0,used);
        return result;
    }
    void backtrack(vector<int>& candidates, int target, int start_index,vector<bool>& used)
    {
        if(sum(com)==target)
        {
            result.push_back(com);
            return;
         }
        if(sum(com)>target)
            return;

        for(int i=start_index;i<candidates.size()&& sum(com)<target;i++)
        {   
            if(candidates[i]>target ||(i>=1&&candidates[i]==candidates[i-1]&& used[i - 1] == false))
            {
                continue;
            }
            else
            {
                com.push_back(candidates[i]);
                used[i]=true;
                backtrack(candidates,target,i+1,used);
                used[i]=false;
                com.pop_back();
            }
        }
        
    }
    int sum(vector<int>& candidates)
    {
        int s=0;
        for(int i:candidates)
            s += i;
        return s;
    }      
};
```



### 5. 216 组合总和 3

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<int> nums{1,2,3,4,5,6,7,8,9};
    vector<vector<int>> combinationSum3(int k, int n) {
        if(n>45||n<(1+k)*k/2)
            return result;
        int s=0;
        backtrack(n,k,1,s);
        return result;
    }
    void backtrack(int target,int n_nums,int startIndex,int & s)
    {
        if(path.size()>n_nums)
            return;
        if(s==target&&path.size()==n_nums)
        {
            result.push_back(path);
            return;
        }
        for(int i=startIndex;i<=9;i++)
        {
            path.push_back(i);
            s += i;
            backtrack(target,n_nums,i+1,s);
            path.pop_back();
            s -= i;
        }
    }
};
```





### 6. Palindrome Partitioning

```c++
class Solution {
public:
    vector<vector<string>> result;
    vector<string> path;
    vector<vector<string>> partition(string s) {
        backtrack(s,0);
        return result;
    }
    void backtrack(string& s,int startIndex)
    {
        if(startIndex>=s.size())
        {
            result.push_back(path);
            return;
        }
        for(int i=startIndex; i<s.size();i++)
        {
            string subString = s.substr(startIndex,i-startIndex+1);
            if(isPalindrome(subString))
            {
                path.push_back(subString);
                backtrack(s,i+1);
                path.pop_back();
            }
        }
        
    }
    bool isPalindrome(string &s)
    {
        int i=0;
        int j=s.size()-1;
        while(i<j)
        {
            if(s[i]!=s[j])
                return false;
            i++;
            j--;
        }
        return true;
    }
};
```



### 8. 78.子集

数组nums中所有独立子集

```c++
class Solution {
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<vector<int>> subsets(vector<int>& nums) {
        backtrack(nums,0);
        return result;
    }
    void backtrack(vector<int>& nums, int startIndex)
    {            
            result.push_back(path);

        if(startIndex>=nums.size())
        {
            return;
        }
        for(int i=startIndex;i<nums.size();i++)
        {        
            path.push_back(nums[i]);

            backtrack(nums,i+1);
            path.pop_back();
        }
    }
};
```

### 9. 80 子集II (nums有重复值)

```c++
class Solution {
    
public:
    vector<vector<int>> result;
    vector<int> path;
    vector<vector<int>> subsetsWithDup(vector<int>& nums) {
        vector<bool> used(nums.size(),false);
        result.push_back(path);
        sort(nums.begin(),nums.end());
        backtrack(nums,0,used);
        return result;

    }
    void backtrack(vector<int>& nums, int startIndex, vector<bool> used)
    {
        if(startIndex>=nums.size())
        {
            return;
        }
        for(int i=startIndex;i<nums.size();i++)
        {
            if(i>startIndex&&nums[i]==nums[i-1]&&!used[i])
                continue;
            else
            {
                used[i] = true;
                path.push_back(nums[i]);
                result.push_back(path);
                backtrack(nums,i+1,used);
                used[i] = false;
                path.pop_back();
            }
        }
    }
};
```

### 10. 排列

```c++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    vector<vector<int>> permute(vector<int>& nums) {
        vector<bool> used(nums.size(),false);
                    backtrack(nums,used);

        return result;
    }
    void backtrack(vector<int>& nums,vector<bool> used)
    {
        if(path.size() == nums.size())
        {
            result.push_back(path);
            return;
        }
         for(int i=0;i<nums.size();i++)
        {
            if(!used[i])
            {
                path.push_back(nums[i]);
                used[i]=true;
                backtrack(nums,used);
                path.pop_back();
                used[i]=false;
            }
        }
    }
};
```

### 11. 排列II

```c++
class Solution {
public:
    vector<int> path;
    vector<vector<int>> result;
    vector<vector<int>> permuteUnique(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        vector<bool> used(nums.size(),false);
        backtrack(nums,used);
        return result;
    }
    void backtrack(vector<int> nums,vector<bool> used)
    {
        if(path.size()==nums.size())
        {
            result.push_back(path);
            return;
        }
        for(int i=0;i<nums.size();i++)
        {
            if(i>0 && nums[i]==nums[i-1] && used[i-1]==false)
                continue;
            if(used[i]==false)
            {
                path.push_back(nums[i]);
                used[i]=true;
                backtrack(nums,used);
                used[i]=false;
                path.pop_back();                
            }                  
        }
        
    }
};
```

### 12. 51 N 皇后

NxN 棋盘放N个Queen，不能在同一行、同一列或同一对角线。

```c++
class Solution {
public:
    vector<vector<string>> result;
    vector<string> path;
    vector<vector<string>> solveNQueens(int n) {   
        vector<vector<bool>> chessboard(n,vector<bool>(n,false));
        backtrack(n,0,chessboard);
        return result;

    }
    void backtrack(int n,int row,vector<vector<bool>>& chessboard)
    {
        if(row==n)
        {   
            result.push_back(path);
            return;
        }
        for(int i=0;i<n;i++)
        {
            chessboard[row][i]=true;
            if(isValid(n,chessboard,row, i))
            {
                path.push_back(constructString(n,i));
                backtrack(n,row+1,chessboard);
                path.pop_back();
            }
            chessboard[row][i]=false;
        }
    }
    string constructString(int n, int i)
    {
        string s(n,'.');
        s[i]='Q';
        return s;
    }
    bool isValid(int n, vector<vector<bool>>& chessboard, int row, int col)
    {
        //check same col
        for(int i=0;i<row;i++)
        {
            if(chessboard[i][col])
                return false;
        }
        
        //check diag
        int i=row-1;
        int j=col-1;
        while(i >=0 && j >=0)
        {
            if(chessboard[i][j])
                return false;
            i--;
            j--;
        }
        i=row-1;
        j=col+1;
         while(i>=0 && j<n)
        {
            if(chessboard[i][j])
                return false;
             i--;
             j++;
        }
        return true;

        
    }
};
```

### 13. 37数独

二重递归

```c++
class Solution {
public:
    void solveSudoku(vector<vector<char>>& board) {
        backtrack(board);
    }
    bool backtrack(vector<vector<char>>& board)
    {       
        for(int i=0;i<9;i++)
            for(int j=0;j<9;j++)
            {
                if(board[i][j]=='.')
                {
                    for(int k=1;k<10;k++)
                    {
                        if(valid(board,i,j,k))
                        {
                            board[i][j]=k-0+'0';
                            if(backtrack(board)) return true;
                            board[i][j]='.';
                        }
                    }
                    return false;
                }
            }
        return true;
    }
    bool valid(vector<vector<char>>& board, int row, int col, int val)
    {
        //check same row
        for(int i=0;i<9;i++)
            if(board[row][i]-'0'==val)
                return false;
        //check same col
        for(int i=0;i<9;i++)
            if(board[i][col]-'0'==val)
                return false;
        //check 3x3
        for(int i=row/3*3;i<row/3*3+3;i++)
            for(int j=col/3*3;j<col/3*3+3;j++)
                if(board[i][j]-'0'==val)
                    return false;
        return true;
    }
};
```



## 贪心算法

### 1.  455. Assign Cookies 每次分配给greed factor最小的孩子

```c++
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(),g.end());
        sort(s.begin(),s.end());
        int gg = 0;
        int ss = 0;
        while(ss<s.size()&gg<g.size())
        {
            if(s[ss]>=g[gg])
                gg++;
            ss++;
        }
        return gg;
    }
};
```



```c++

```

### 2. Medium, 435. Non-overlapping Intervals

```c++
// Case 1:-
// ------------------   -----------------
// |   Interval 1   |   |   Interval 2  |
// ------------------   -----------------

//Case 2:-
// ------------------
// |   Interval 1   |
// ------------------
//            ------------------
//            |    Interval 2  |
//            ------------------

//Case 3:-
//  --------------------
//  |    Interval 1    |
//  --------------------
//     --------------
//     | Interval 2 |
//     --------------
class Solution 
{
public:
    int eraseOverlapIntervals(vector<vector<int>>&v) 
    {
        sort(v.begin(),v.end());
        int count=0,prev=0,n=v.size();
        for(int i=1;i<n;i++)
        {
            if(v[prev][1]<=v[i][0]) // Non-overlapping case(Case 1)
            {
                prev=i;
            }
            else 
            {
                count++;
                if(v[prev][1]>v[i][1])                prev=i;

            }
        }
        return count;
    }
};
```

### 3. 452 . Minimum Number of Arrows to Burst Balloons

与上题有点类似，先排序，然后总是扎一个区间的最后，看下一个区间的开头是否跟最后一个元素重叠

```c++
class Solution {
public:
    int findMinArrowShots(vector<vector<int>>& points) {
        sort(points.begin(),points.end(),[](const vector<int> &o1, const vector<int> &o2) 
        {
            return (o1[1] < o2[1]);
         });
              
        int start=points[0][0];
        int end = points[0][1];
        int result = 1;
        if(points.size()==1) return 1;
        for(int i=1;i<points.size();i++)
        {
            if(points[i][0]<=end){
                continue;
            }
            else
            {
                result++;
                end=points[i][1];
            }
        }
        return result;
    }
};
```

### 4. 406. Queue Reconstruction by Height

同样，现根据第一个数从大到小排

然后从大往小插数；

对于相同的第一个数，第二个数为插入时的index

```c++
class Solution {
public:
    vector<vector<int>> reconstructQueue(vector<vector<int>>& people) {
        vector<vector<int>> result;
        sort(people.begin(),people.end(),[](const vector<int> &p1, const vector<int> &p2) 
        {
            return ( (p1[0] > p2[0]) || (p1[0]==p2[0] && p1[1]<p2[1]));
         });
        for(auto person:people){
            result.insert(result.begin()+person[1],person);
        }
        return result;
        
    }

};
```

### 5  easy, 121. Best Time to Buy and Sell Stock

随时更新最小的那个值；

然后如果当前值减去最小的那个大于当前最大获利，更新最大获利；

如果当前价格小于最小价格，更新

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int currentMin = INT_MAX;
        int maxPro = 0;
        for(int i=0; i<prices.size(); i++)
        {
            if(prices[i]-currentMin>maxPro){
                maxPro=prices[i]-currentMin;
                }
            currentMin=min(prices[i],currentMin);

        }
        return maxPro;
    }
};
```

### 6. easy, best time to buy and sell stock ||

```c++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int profit=0;
        int current=prices[0];
        for(size_t i=1;i<prices.size();i++)
        {
            if(prices[i]>current)
            {
                profit += prices[i]-current;
            }
            current=prices[i];
        }
        return profit;
    }
};
```

### 7. 种植花朵，605， Can Place Flowers (Easy)

这个主要是在判别两边的时候有个trick，可以写成（i==0||flowerbed[i-1]==0) && （i==flowerbed.length()-1||flowerbed[i+1]==0)

```c++
class Solution {
public:
    bool canPlaceFlowers(vector<int>& flowerbed, int n) {
        int i=0;
        int count=0;
        //find 1st 0, its previous value is either 0 or non
        
        while(i<flowerbed.size())
        {
            if(flowerbed[i]==0 && (i==0||flowerbed[i-1]==0) && (i==flowerbed.size()-1||flowerbed[i+1]==0))
            {
                count++;
                i++;
            }
            i++;
            if(count>=n) return true;
        }
        return false;
    }
};
```

### 8. 392, 判断是否子序列，easy

双指针可以做

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int is=0, it=0;
        if(s.length()==0) return true;
        if(t.length()<=s.length()) return s==t;
        while(it<t.size())
        {
            if(s[is]==t[it])
            {
                is++;
            }
            if(is==s.size()) return true;
            it++;
        }
        return false;       
    }
};
```

### 9.判断一个数组是否能只修改一个数就成为非递减数组。665， medium

1: 比较i与i-2；

2：注意i=1的时候

3：注意i与i-2相等的情况

```c++
class Solution {
public:
    bool checkPossibility(vector<int>& nums) {
        int n=0, i=1;
        if(nums.size()==1) return true;
        while(i<nums.size())
        {
            if(nums[i]<nums[i-1])
            {
                if(++n>1) return false;
                if(i==1||nums[i-2]<=nums[i])
                    nums[i-1]=nums[i];
                else
                    nums[i]=nums[i-1];
            }
            
           
            i++;
            
        }
        return true;
    }
};
```

### 10. 子数组最大的和

maximum subarray

两个变量：local和globalmax

localMax=max(nums[i],localMax+nums[i])

globalMax=max(globalMax,localMax)

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        int globalMax=-10000,localMax=-10000;
        for(int i=0;i<nums.size();i++)
        {
            localMax=max(localMax+nums[i],nums[i]);
            globalMax=max(localMax,globalMax);
        }
        return globalMax; 
    }
};
```

### 11. 763, Medium, Partition labels

第一次循环先找到该字母最后出现的位置

然后用j来表示当前出现过得字母的最后位置，如果i==j，就添加到结果中去，并更新archor（当前subarray的starting point）

```c++
class Solution {
public:
    vector<int> partitionLabels(string s) {
        map<char,int> last;
        vector<int> result;
        for(int i=0;i<s.size();i++)
            last[s[i]]=i;
        int j=0;
        int anchor=0;
        for(int i=0;i<s.size();i++)
        {
            j=max(j,last[s[i]]);
            if(i==j)
            {
                result.push_back(i-anchor+1);
                anchor=i+1;
            }
        }
        return result;
    }
};
```



## 搜索

### BFS

```
BFS(startV)
{
	add startV to frontierQueue;
	add startV to discoveredSet;

	while(frontierQueue is not empty)
	{
 		currentV=deque from frontierQueue;
 		"Visit" each currentV;
 		for each Vertex adjacent to currentV
 		{
 			if Vertex is not in discoveredSet
 			{
 				enqueue(vertex) to frontierQueue;
 				add Vertex to disconveredSet;
 			}
 		}
	}
}
```

### DFS

```
DFS(startV)
{
	push startV to stack;
    while(stack is not empty)
    {
    	currentV=Pop stack;
    	if currentV is not in VisitedSet
    	{
    		add currentV to visitedSet;
    		"visit" currentV
    		for each adjacent adjV of currentV
    		{
    			push adjV to stack;
    		}
    	}
    }

}
```



## 动态规划

**对于动态规划问题, 这五步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序
5. 举例推导dp数组

**找问题的最好方式就是把dp数组打印出来，看看究竟是不是按照自己思路推导的！**

一些同学对于dp的学习是黑盒的状态，就是不清楚dp数组的含义，不懂为什么这么初始化，递推公式背下来了，遍历顺序靠习惯就是这么写的，然后一鼓作气写出代码，如果代码能通过万事大吉，通过不了的话就凭感觉改一改。

这是一个很不好的习惯！

**做动规的题目，写代码之前一定要把状态转移在dp数组的上具体情况模拟一遍，心中有数，确定最后推出的是想要的结果**。

然后再写代码，如果代码没通过就打印dp数组，看看是不是和自己预先推导的哪里不一样。

如果打印出来和自己预先模拟推导是一样的，那么就是自己的递归公式、初始化或者遍历顺序有问题了。

如果和自己预先模拟推导的不一样，那么就是代码实现细节有问题。

**这样才是一个完整的思考过程，而不是一旦代码出问题，就毫无头绪的东改改西改改，最后过不了，或者说是稀里糊涂的过了**。



### 基础题目

### 0. 斐波那契数列，509,easy

1. 确定dp数组以及下标的含义

dp[i]的定义为：第i个数的斐波那契数值是dp[i]

2. 确定递推公式: dp[i] = dp[i - 1] + dp[i - 2]
3. dp数组如何初始化: dp[0]=0;dp[1]=1;
4. 确定遍历顺序: i从小到大
5. 举例推导dp数组

```c++
class Solution {
public:
    int fib(int n) {
        if(n<=1) return n;
        int dp_1=1;
        int dp_2=0;
        int dp_i;
        for(int i=2;i<=n;i++)
        {
            dp_i=dp_1+dp_2;
            dp_2=dp_1;
            dp_1=dp_i;
        }
        return dp_i;
    }
};
```

这样的时间复杂度为O（n）;递归的是0（n^2） （想想递归树)

### 1. 爬楼梯，LeetCode 70

题目描述：有 N 阶楼梯，每次可以上一阶或者两阶，求有多少种上楼梯的方法。

1. 确定dp数组以及下标的含义

​			dp[i]： 爬到第i层楼梯，有dp[i]种方法

2. 递推公式

​	**dp[i]=dp[i-1]+dp[i-2]**

3. 初始化： dp[1]=1;dp[2]=2; 从3开始
4. 确定遍历顺序：从小到大
5. 举例推导数组

```
class Solution {
public:
    int climbStairs(int n) {
        int step1=1;
        int step2=2;
        int curr=0;
        if(n<3)
            return n;
        for(int i=3;i<=n;i++)
        {   
            curr=step1+step2;
            step1=step2;
            step2=curr;
        }
        return curr;
    }
};
```

### 2. 746, 使用最小花费爬楼梯 easy, Min cost climbing stairs

1. 确定dp数组以及下标含义

   **到达第i个台阶所花费的最少体力为dp[i]**

2. 确定递推公式

   dp[i] = min( dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])

3. 初始化:

   dp[0] = 0

   dp[1] = 0

4. 确定顺序：从i=2开始

5. 例子

```c++
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        vector<int> dp(2);
        dp[0]=0;
        dp[1]=0;
        int res;
        
        for(int i=2;i<=cost.size();i++)
        {
            res=min(dp[0]+cost[i-2],dp[1]+cost[i-1]);
            dp[0]=dp[1];
            dp[1]=res;
        }
        return res;
    }
};
```

### 3. 62, unique paths

1. 确定dp含义：

   dp[i,j] 是从top left到[i,j]的path数

2. 递推公式：

   dp[i,j]=dp[i-1,j]+dp[i,j-1]

3. 初始化： 把矩阵的第一列和第一行统一为1

   dp[0, 0,1...n-1]=1; dp[0,...m-1, 0]=1

4. 填满矩阵

```c++
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> v(m,vector<int>(n,0));
        for(int i=0;i<m;i++)
        {
            v[i][0]=1;
        }
        for(int j=0;j<n;j++)
        {
            v[0][j]=1;
        }
        for(int i=1;i<m;i++)
            for(int j=1;j<n;j++)
            {
                v[i][j]=v[i-1][j]+v[i][j-1];
            }
        return v[m-1][n-1]; 
    }
};
```

### 4. 62, unique paths||

1. 确定dp含义：

   dp[i,j] 是从top left到[i,j]的path数

2. 递推公式：

   dp[i,j]=(1-obstacle[i,j])*[ (1-obstacle[i-1,j])dp[i-1,j]+  (1-obstacle[i,j-1]) dp[i,j-1] ], until meet 1st 1

3. 初始化： 把矩阵的第一列和第一行统一为1, 知道遇见第一个1

   dp[0, 0,1...n-1]=1; dp[0,...m-1, 0]=1

4. 填满矩阵



```c++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

### 5. medium, 343. 整数拆分

1. 确定dp含义：

   dp[i] 是把i拆成很多和为i的整数，其中乘积最大的那个数

2. 递推公式：

   需要遍历; j=1:i-2 (i>=3); dp[i]=max([  max(  [i-j]xj,  dp[i-j]xj )]

3. 初始化： dp[2]=1

4. 填满矩阵



```c++
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n+1);
        dp[2]=1;
        for(int i=3;i<=n;i++)
            for(int j=1;j<i-1;j++)
        {
            dp[i]=max(dp[i],max((i-j)*j, dp[i-j]*j));
        }
        return dp[n];
    }
};
```

### 6. 96, medium, 不同的二叉搜索树

给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

1. 定义dp[i]: 以1,2....i为节点的unique 二叉搜索树的数量

2. 确定递推公式

   观察一下dp[3]，这么几种情况：

   - 以1 为head，情况的数量正好为dp[2]
   - 以2为head，二叉树的性质左边为1，右边也为1，这种数量为dp[1]*dp[1]
   - 以3为head，左子树为dp[2]
   - 总结递推公式为，对于每一个dp[i]，遍历j从1到i做为head，每种 j 对应得情况数为dp[j-1]*dp[i-j]

3. 初始化：dp[0]=1;dp[1]=1



```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1);
        dp[0]=1;
        dp[1]=1;
        for(int i=2;i<=n;i++)
            for(int j=1;j<=i;j++)
                dp[i]+=dp[j-1]*dp[i-j];
        return dp[n];
        
    }
};
```

### 二维数组0-1背包

有N件物品和一个最多能背重量为W 的背包。第i件物品的重量是weight[i]，得到的价值是value[i] 。**每件物品只能用一次**，求解将哪些物品装入背包里物品价值总和最大。

1. 确定dp数组以及下标定义 dp\[i]\[j]：在下标为0-(i-1)物品中选，重量最多为j，最大价值总和

2. 递推公式：

   考虑放第i个物品的话，dp\[i][j]=dp\[i-1][j-weight(i)]+value(i)

   如果不放第i个物品的话，dp\[i][j]=dp\[i-1][j]

   thus dp\[i][j]=max(dp\[i-1][j], dp\[i-1][j-weight[i]])+value[i]

3. 初始化 

   当j=0的时候, dp\[i][0]全为0

   当i=0的时候，dp\[0][weight[0]-max_weight] = value[0]

4. 确定遍历顺序：

   先遍历物品或者重量都可以

```c++
void test_2_wei_bag_problem1() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 二维数组
    vector<vector<int>> dp(weight.size(), vector<int>(bagWeight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagWeight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

        }
    }

    cout << dp[weight.size() - 1][bagWeight] << endl;
}

int main() {
    test_2_wei_bag_problem1();
}
```

### 1. 416. Partition Equal Subset Sum

0-1背包, weight=nums, value=nums

1. 定义dp[j]: 从nums里面选，能凑成的 最大的小于等于 最大容量J（包含J)的数

2. 其实可以用二维数组, i 表示 前I个数，但是可以用一维数组，不过遍历J时需要从后往前因为从前往后的话会在考虑max时把前面已经加过的考虑进去，而后面的不会，所以从后往前遍历。 初始化即为把第一行全设为0 （只能选0个，当然为0）

   for(int i=0;i<nums.size();i++)

   ​	for(int j=target; j>=nums[i];j--)

   ​		dp[j]=max(dp[j],dp[j-nums[i]]+nums[i])

```c++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int target=0;
        for(int i:nums)
            target += i;
        if(target%2) return false;
        target=target/2;
        
        vector<int> v(target+1);
    
        for(int i=0;i<nums.size();i++)
        {
            for(int j=target;j>=nums[i];j--)
            {
                v[j] = max(v[j],v[j-nums[i]]+nums[i]);
             }
        }
        return (v[target]==target);
    }
};
```



### 2. 1049. Last Stone Weight II

本题其实就是尽量让石头分成重量相同的两堆，相撞之后剩下的石头最小，**这样就化解成01背包问题了**, 变成和上题一样的了

定义dp[j]: 从stones里面选，能凑成的 最大的小于等于 最大容量J（包含J)的数

```c++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int s=0;
        for(int i:stones)
            s += i;
        int target=s/2;
        vector<int> dp(target+1);
        for(int i=0;i<stones.size();i++)
            for(int j=target;j>=stones[i];j--)
                dp[j]=max(dp[j],dp[j-stones[i]]+stones[i]);
        return s-2*dp[target];
    }
};
```

### 3. 494. Target Sum

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

示例：

输入：nums: [1, 1, 1, 1, 1], S: 3
输出：5

0： 转换成0-1背包，这个想着从所有的数中挑选出一些为正，剩下的为负。那这些正数的和为（S+sum(nums)）/2

1. 定义dp：dp[i] 为从nums中任意挑选，其和为i的组合种数 （二维情况为dp\[i][j], i表示在nums的前i个数中选，j表示和为j）

2. 关系式：写成二维的比较容易理解 dp\[i][j] = dp\[i-1][j]+dp\[i-1][j-nums[i]]; 这个变成1d的就是dp[j] = dp[j]+dp[j-nums[i]]   for (i=0:nums.size())

3. 初始化: 0的时候和为1

   从递归公式可以看出，在初始化的时候dp[0] 一定要初始化为1，因为dp[0]是在公式中一切递推结果的起源，如果dp[0]是0的话，递归结果将都是0。

   dp[0] = 1，理论上也很好解释，装满容量为0的背包，有1种方法，就是装0件物品。



```c++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int s=0;
        for(int i:nums)
            s += i;
        if((s+target)%2 || s<abs(target)) return false;
        int t=(s+target)/2;
        vector<int> dp(t+1,0);

        dp[0]=1;
        for (int i = 0; i < nums.size(); i++) {
            for (int j = t; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[t];
    }

};
```

### 4. Medium, 474, Ones and Zeroes

1. 确定dp数组（dp table）以及下标的含义

**dp\[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp\[i][j]**。

2. 确定递推公式: 这个其实有三层循环：最外层遍历物品；里面两层从大到小遍历weight

   第k个物品加不加：dp\[i][j] = max(dp\[i][j])，1+dp\[i-stat0\[k]][j-stat1[k]]

3. 初始化：全初始化为0

```c++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        vector<vector<int>> res=get01stat(strs);
        vector<int> stat0=res[0];
        vector<int> stat1=res[1];
        vector<vector<int>> dp(m+1,vector<int>(n+1));
        
        for(int k=0;k<strs.size();k++)
            for(int i=m;i>=stat0[k];i--)
                for(int j=n;j>=stat1[k];j--)
                    dp[i][j]=max(dp[i-stat0[k]][j-stat1[k]]+1,dp[i][j]);
        return dp[m][n];
        
    }
    vector<vector<int>> get01stat(vector<string> strs)
    {
        vector<vector<int>> res(2,vector<int>(strs.size()));
        for(int i=0;i<strs.size();i++)
        {
            res[0][i]=std::count(strs[i].begin(),strs[i].end(),'0');
            res[1][i]=std::count(strs[i].begin(),strs[i].end(),'1');
        }
        return res;
    }
};
```

### 完全背包 （物品可以放多次）

**如果求组合数就是外层for循环遍历物品，内层for遍历背包**。

**如果求排列数就是外层for遍历背包，内层for循环遍历物品**。

### 1.  518, medium Coin Change 2

You are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.

Return *the number of combinations that make up that amount*. If that amount of money cannot be made up by any combination of the coins, return `0`.

1. 定义dp：dp[i]; amount为i的组合数

2. 递推：对于第j个物品 dp[i]=dp[i-coins[j]]+dp[i]；外循环为物品，内循环为amount，但是内循环为**从小到大**, 这样就可以把前面的重复使用了

3. 初始化：首先dp[0]一定要为1，dp[0] = 1是 递归公式的基础。

   从dp[i]的含义上来讲就是，凑成总金额0的货币组合数为1。

   ```c++
   class Solution {
   public:
       int change(int amount, vector<int>& coins) {
           vector<int> dp(amount+1);
           dp[0]=1;
           for(int i=0;i<coins.size();i++)
               for(int j=coins[i];j<=amount;j++)
                   dp[j]=dp[j]+dp[j-coins[i]];
           return dp[amount];
       }
   };
   ```



### 2. 377, medium,  Combination Sum IV



Given an array of **distinct** integers `nums` and a target integer `target`, return *the number of possible combinations that add up to* `target`.

这个其实是排列（1,5）和（5,1）算两次

**如果本题要把排列都列出来的话，只能使用回溯算法爆搜**。但是是求排列的个数

1. 定义dp: dp[i]: 从nums中选择总和为target的排列数的总数

2. 递推：dp[i]=dp[i]+dp[i-nums[j]] 注意**dp[j] < INT_MAX - dp[j - nums[i]]** 不能写成**dp[j]+ dp[j - nums[i]] < INT_MAX **； 因为前者可能会大于INT_MAX从而无法以同精度比较

3. 初始化：dp[0]=1，否则dp永远是0

4. 顺序：

   完全背包，需要注意遍历顺序

   如果求组合数就是外层for循环遍历物品，内层for遍历背包。

   如果求排列数就是外层for遍历背包，内层for循环遍历物品。

```c++
class Solution {
public:
    int combinationSum4(vector<int>& nums, int target) {
        vector<int> dp(1+target);
        dp[0]=1;
        for(int j=0;j<=target;j++)
            for(int i=0;i<nums.size();i++)
                if(j>=nums[i]  && dp[j] < INT_MAX - dp[j - nums[i]]) dp[j]=dp[j]+dp[j-nums[i]];
        return dp[target];
    }
};
```

### 3. 322. Coin Change

这道题先循环哪个都可以

递推公式dp[j]=min(dp[j-coins[i]]+1,dp[j])

初识化时默认值为INT_MAX, dp[0]=0;

```c++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount+1,INT_MAX);
        dp[0]=0;
        for(int i=0;i<coins.size();i++)
            for(int j=coins[i];j<=amount;j++)
                if(dp[j-coins[i]]!=INT_MAX)
                    dp[j]=min(dp[j-coins[i]]+1,dp[j]);

        return dp[amount]==INT_MAX? -1:dp[amount];
    }
};
```



### 4. 279 Perfect Squares

Given an integer `n`, return *the least number of perfect square numbers that sum to* `n`.

A **perfect square** is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, `1`, `4`, `9`, and `16` are perfect squares while `3` and `11` are not.

```c++
class Solution {
public:
    int numSquares(int n) {
        vector<int> dp(n+1,INT_MAX);
        if(n==1) return 1;
        dp[0]=0;
        
        for(int i=0;i<=n;i++)
            for(int j=1;j*j<=i;j++)
                dp[i]=min(dp[i-j*j]+1,dp[i]);
    
        return dp[n];
    }
};
```



### 139



1. 确定dp数组以及下标的含义

**dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**。

2. dp[i]=dp[j]&&dp[i-j]

 



```c++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(),wordDict.end());
        vector<bool> dp(s.size()+1,false);
        dp[0]=true;
        for(int i=0;i<=s.size();i++)
        {
            for(int j=0;j<i;j++)
            {
                string substring=s.substr(j,i-j);
                if((wordSet.find(substring)!=wordSet.end())&&dp[j])
                    dp[i]=true;
            }
                
        }       
        return dp[s.size()];
        
    }
};
```



### 2. 	强盗抢劫,

题目描述：抢劫一排住户，但是不能抢邻近的住户，求最大抢劫量。

定义 dp 数组用来存储最大的抢劫量，其中 dp[i] 表示抢到第 i 个住户时的最大抢劫量。

由于不能抢劫邻近住户，如果抢劫了第 i -1 个住户，那么就不能再抢劫第 i 个住户，所以

$$dp[i]=max(dp[i-1],dp[i-2]+nums[i])$$

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> dp(nums.size());
        dp[0]=nums[0];
        if(nums.size()==1) return dp[0];
        dp[1]=max(nums[0],nums[1]);
        if(nums.size()==2) return dp[1];

        for(int i=2;i<nums.size();i++)
            dp[i]=max(dp[i-2]+nums[i],dp[i-1]);
        return dp[nums.size()-1];
            
    }
};
```

### 2, 213. House Robber II环形



对于一个数组，成环的话主要有如下三种情况：

- 情况一：考虑不包含首尾元素

[![213.打家劫舍II](https://camo.githubusercontent.com/cda61fe4326306f85a0bb289439361feca5c8d6f06b034c822243d97651b4895/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303132393136303734383634332e6a7067)](https://camo.githubusercontent.com/cda61fe4326306f85a0bb289439361feca5c8d6f06b034c822243d97651b4895/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303132393136303734383634332e6a7067)

- 情况二：考虑包含首元素，不包含尾元素

[![213.打家劫舍II1](https://camo.githubusercontent.com/7ddcbfca80ef22e908531cb5226a76f679fed6740348da9b3de45c1a7fddd848/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303132393136303832313337342e6a7067)](https://camo.githubusercontent.com/7ddcbfca80ef22e908531cb5226a76f679fed6740348da9b3de45c1a7fddd848/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303132393136303832313337342e6a7067)

- 情况三：考虑包含尾元素，不包含首元素

[![213.打家劫舍II2](https://camo.githubusercontent.com/c6200435004b9fefd988195266a994ed85d727352104ea2192067ba8eed8942e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303132393136303834323439312e6a7067)](https://camo.githubusercontent.com/c6200435004b9fefd988195266a994ed85d727352104ea2192067ba8eed8942e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303231303132393136303834323439312e6a7067)

**注意我这里用的是"考虑"**，例如情况三，虽然是考虑包含尾元素，但不一定要选尾部元素！ 对于情况三，取nums[1] 和 nums[3]就是最大的。

**而情况二 和 情况三 都包含了情况一了，所以只考虑情况二和情况三就可以了**。

分析到这里，本题其实比较简单了。 剩下的和[198.打家劫舍](https://programmercarl.com/0198.打家劫舍.html)就是一样的了。

```c++
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size()==1) return nums[0];
        int res1=robHelper(nums,0,nums.size()-2);
        int res2=robHelper(nums,1,nums.size()-1);
        return max(res1,res2);
    }
    int robHelper(vector<int>& nums,int s,int e)
    {
        vector<int> dp(nums.size());
        dp[s]=nums[s];
        if(s==e) return dp[s];
        dp[s+1]=max(nums[s],nums[s+1]);
        for(int i=s+2;i<=e;i++)
            dp[i]=max(dp[i-1],dp[i-2]+nums[i]);
        return dp[e];
    }
};
```

### 子序列问题

### 1/300 最长递增子序列

1. dp[i]定义：从0到i最长上升子序列的长度

2. 状态转移方程：

   if(nums[i]>nums[j]) dp[i]=max(dp[i],dp[j]+1)

3. 初始化：dp[0]=1; dp初始化为1

4. 确定遍历顺序：i从小到大, j 从前到后

### 2 /1143. Longest Common Subsequence

这里dp的size定为text的长度加1，所以dp[i]对应的是text[i-1]

1. dp\[i][j]定义：从text1[0 to i-1], text2[0 to j-1]的最大子序列的长度
2. 状态转移方程：if(text[**i-1**]==text[**j-1**]) dp\[i][j]=dp\[i-1][j-1]+1

```c++
class Solution {
public:
    int longestCommonSubsequence(string text1, string text2) {
        vector<vector<int>> dp(text1.size()+1,vector<int>(text2.size()+1,0));
        for(int i=1;i<=text1.size();i++)
            for(int j=1;j<=text2.size();j++)
            {
                if(text1[i-1]==text2[j-1]) dp[i][j]=dp[i-1][j-1]+1;
                else dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        return dp[text1.size()][text2.size()];
    }
};
```

### 3. 1035 Uncrossed Lines

其实就是找最长公共子序列，和上道题一样

```c++
class Solution {
public:
    int maxUncrossedLines(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size()+1,vector<int>(nums2.size()+1));
        
        for(int i=1;i<nums1.size()+1;i++)
            for(int j=1;j<nums2.size()+1;j++)
            {
                if(nums1[i-1]==nums2[j-1])
                {
                    dp[i][j]=dp[i-1][j-1]+1;
                }
                 else 
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }    
        return dp[nums1.size()][nums2.size()];

        }

};
```

### 4.674. Longest Continuous Increasing Subsequence

**连续+递增**

            if(nums[i]>nums[i-1])
                dp[i] = dp[i-1]+1;

```c++
class Solution {
public:
    int findLengthOfLCIS(vector<int>& nums) {
        vector<int> dp(nums.size(),1);
        int result=1;
        for(int i=1;i<nums.size();i++)
        {    
            if(nums[i]>nums[i-1])
            {
                dp[i] = dp[i-1]+1;
                result=max(result,dp[i]);
            }
        }
        return result;
    }

};
```

### 5. 718. Maximum Length of Repeated Subarray

1. dp\[i][j]: nums1[0-i-1] 与nums2[0-j-1]的最长重复subarray的长度
2. if(dp[i-1]==dp[j-1]) dp\[i][j]=dp\[i-1][j-1]+1
3. 初始化：0，i/j从1开始循环

```c++
class Solution {
public:
    int findLength(vector<int>& nums1, vector<int>& nums2) {
        vector<vector<int>> dp(nums1.size()+1,vector<int>(nums2.size()+1));
        int result=0;
        for(int i=1;i<=nums1.size();i++)
            for(int j=1;j<=nums2.size();j++)
                if(nums1[i-1]==nums2[j-1])
                {
                    dp[i][j]=dp[i-1][j-1]+1;
                    result=max(result,dp[i][j]);
                }
        return result;
    }
};
```

### 6. 53 Maximum Subarray

dp[i]=max(nums[i-1],dp[i-1]+nums[i-1])

```c++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size()+1);
        int result=nums[0];
        for(int i=1;i<=nums.size();i++)
        {
            dp[i]=max(nums[i-1],dp[i-1]+nums[i-1]);
            result=max(result,dp[i]);
    
        }
        return result;
    }
};
```

### 编辑距离

### 1. 392 判断子序列

这道题双指针也可以

1. 定义dp\[i][j]: 字符串t前i个字符和字符串s前j个字符共同子序列的最大长度（不一定连续）

2. 递推公式：

   if[t[i]==s[j]] dp\[i][j]=dp\[i][j]+1

   else dp\[i][j]=max(dp\[i-1][j],dp\[i][j-1])

3. 初始化：全部为0，从dp\[1][1]开始

4. 迭代顺序：

```c++
class Solution {
public:
    bool isSubsequence(string s, string t) {
     vector<vector<int>> dp(s.size()+1,vector<int>(t.size()+1));
        for(int i=1;i<=s.size();i++)
            for(int j=1;j<=t.size();j++)
            {
                if(s[i-1]==t[j-1])
                    dp[i][j]=dp[i-1][j-1]+1;
                else
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        return dp[s.size()][t.size()]==s.size();
    }
};
```

### 115 不同的子列

给定一个字符串 s 和一个字符串 t ，计算在 s 的子序列中 t 出现的个数。

1. 确定dp：dp\[i][j] 字符串s[0:i-1]中子列t\[0:j-1]出现的次数
2. 递推公式：如果s[i-1] != t[i-1]，则dp\[i][j]=dp\[i-1][j]; 反之dp\[i][j]=dp\[i-1][j-1]+dp\[i-1][j]
3. 初始化：dp\[i][0]=1; 否则dp就全是0了

```c++
class Solution {
public:
    int numDistinct(string s, string t) {
        vector<vector<uint64_t>> dp(s.size()+1,vector<uint64_t>(t.size()+1));
        for(int i=0;i<s.size();i++)
            dp[i][0]=1;
        for(int i=1;i<=s.size();i++)
        {
            for(int j=1;j<=t.size();j++)
            {
                if(s[i-1]==t[j-1])
                    dp[i][j]=dp[i-1][j-1]+dp[i-1][j];
                else
                    dp[i][j]=dp[i-1][j];
            }
        }
        return dp[s.size()][t.size()];
    }
    };
```

### 583. Delete Operation for Two Strings

其实就是求最长公共子序列，然后len(s1)+len(s2)-2*max_length

```c++
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size()+1,vector<int>(word2.size()+1));
        for(int i=1;i<=word1.size();i++)
            for(int j=1;j<=word2.size();j++)
            {
                if(word1[i-1]==word2[j-1])
                    dp[i][j]=dp[i-1][j-1]+1;
                else
                    dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
            }
        return word1.size()+word2.size()-2*dp[word1.size()][word2.size()];
    }
};
```

### 72 . Edit Distance

Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.

1. **dp[i][j] 表示以下标i-1为结尾的字符串word1，和以下标j-1为结尾的字符串word2，最近编辑距离为dp[i][j]**。

2. 确定递推公式

   ```c++
               if(word1[i-1]==word2[j-1])
                   dp[i][j]=dp[i-1][j-1];
               else
                   dp[i][j]=min(dp[i-1][j]+1,min(dp[i][j-1]+1,dp[i-1][j-1]+1));
   ```

3. 初始化

   dp\[0][i]: 其中一个是空子串，需要i次操作全部删除

   for (int i = 0; i <= word1.size(); i++) dp[i][0] = i;
   for (int j = 0; j <= word2.size(); j++) dp[0][j] = j;



### 子序列

### 647 回文子串

给定一个字符串s, 判断有多少个回文子串

1. 定义dp\[i][j] : 从index i 开始到index j的字符串**是否为回文子串**

2. 递推公式：

   如果s[i-1]==s[j-1]，要看剩下的字符串。当长度小于等于2时，设置为TRUE，否则看到dp\[i+1][j-1]所以：

   if(s[i-1]==s[j-1]) 

   ​	if (j-i>1) if(dp\[i-1][j-1]) dp\[i][j]=true result ++;

   ​	else dp\[i][j]=true, result++

   如果不相等的话，不做任何操作

```c++
class Solution {
public:
    int countSubstrings(string s) {
        vector<vector<bool>> dp(s.size()+1,vector<bool>(s.size()+1,false));
        //dp[i][j]: start from i end at j
        int result=0;
        for(int i=s.size();i>=1;i--)
            for(int j=i;j<=s.size();j++)
            {
                if(s[i-1]==s[j-1])
                {
                    if(j-i<=1)
                    {
                        result++;
                        dp[i][j]=true;
                    }
                    else if(dp[i+1][j-1])
                    {
                        result++;
                        dp[i][j]=true;
                    }
                        
                 }
            }
        return result;
                
    }
};
```

### 516 最长的回文子序列

可以不连续

1. 定义dp\[i][j]: 以i开头j结尾的子字符串最长回文子序列长度

2. 递推：

   if(s[i-1]==s[j-1]) 

   ​	if(j-i<=1) dp\[i][j]=j-i+1

   ​	else  dp\[i][j]=dp\[i+1][j-1]+2

   else

   ​	dp\[i][j]=max(dp\[i+1][j],dp\[i][j-1])

3. 循环顺序： 明显i从大到小，j从小到大

```c++
class Solution {
public:
    int longestPalindromeSubseq(string s) {
        vector<vector<int>> dp(s.size()+1,vector<int>(s.size()+1));
        int length=0;
        for(int i=s.size();i>0;i--)
            for(int j=i;j<=s.size();j++)
            {
                if(s[i-1]==s[j-1])
                {
                    if(j-i<=1)
                        dp[i][j]=j-i+1;
                    else
                        dp[i][j]=dp[i+1][j-1]+2;
                }
                else
                    dp[i][j]=max(dp[i+1][j],dp[i][j-1]);
                length=max(length,dp[i][j]);
            }
        return length;
    }
    int max(int a,int b)
    {
        return a>=b? a:b;
    }
};
```

## 位运算

需要记住的：

- n&(n-1) 去除位数最低的那一位的1
- n&（-n）: 得到n位级表示中最低的那一位1. (-n即为n的反码+1)
- 利用 x ^ x = 0 的特点，可以将三个数中重复的两个数去除，只留下另一个数。
- 利用 x ^ 1s = ~x 的特点，可以将一个数的位级表示翻转

### 1. 461 Hamming Distance

```c++
class Solution {
public:
    int hammingDistance(int x, int y) {
        int dis=0;
        while(x>0 || y>0)
        {
            if(x%2 != y%2)
                dis++;
            x=x>>1;
            y=y>>1;
        }
        return dis;
    }
};
```

### 2. 136. Single Number

```c++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ret=0;
        for(int i:nums)
            ret=i^ret;
        return ret;
    }
};
```

### 3. 268 Missing Number (Easy)

```c++
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        int result=0;
        for(int i=0;i<nums.size();i++)
            result = result^i^nums[i];
        result=result^nums.size();
        return result;
    }
};
```

### 4. 260,single num|||数组中不重复的两个元素

先把所有的元素做一遍异或，得到不重复两个元素的异或的结果。

然后找到最右边两个数不同的那一位 bitmask &= -bitmask

```c++
class Solution {
public:
    vector<int> singleNumber(vector<int>& nums) {
        // Get the XOR of the two numbers we need to find
        unsigned int bitmask = accumulate(nums.begin(), nums.end(), 0, bit_xor<int>());
        // Get its last set bit
        bitmask &= (-bitmask);
        vector<int> result(2);
        
        for(int i:nums)
        {
            if(i&bitmask)
                result[0] ^= i;
            else
                result[1] ^= i;
        }
        return result;
    }
};
```

### 6. 190. Reverse Bits

```c++
class Solution {
public:
    uint32_t reverseBits(uint32_t n) {
        uint32_t result=0;
        int power=31;
        while(n!=0)
        {
            result +=  (n & 1)<<power;
            power--;
            n = n>>1;
        }
        return result;
    }
};
```

### 7. 231 power of 2

```c++
class Solution {
public:
    bool isPowerOfTwo(int n) {
        int n_one=0;
        while(n>0)
        {
            n_one += (n&1)==1;
            n=n>>1;
        }
        return n_one==1;
    }
};
```

### 8. 342 power of 4

```
class Solution {
public:
    bool isPowerOfFour(int n) {
        int n_one=0;
        int ind_one=0;
        int i=0;
        while(n>0)
        {
            n_one += n&1;
            ind_one = n&1? i:0;
            n=n>>1;
            i++;
        }
        if(n_one!=1 || ind_one%2) return false;
        return true;
    }
};
```



### 9. 693 判断一个数的位级表示是否不会出现连续的 0 和 1  Binary Number with Alternating Bits 

```c++
class Solution {
public:
    bool hasAlternatingBits(int n) {
        int last=n&1;
        n=n>>1;
        while(n>0)
        {
            if(last==(n&1))
                return false;
            last=n&1;
            n=n>>1;
        }
        return true;
    }
};
```

### 10. 求一个数的补码 476. Number Complement (Easy)

```c++
class Solution {
public:
    int findComplement(int n) {
        int result=0;
        int n_power=0;
        while(n>0)
        {
            result += (1-n&0x1)<<n_power;
            n=n>>1;
            n_power++;
        }
        return result;

    }
};
```

### 11. 371 不用加号实现加法

1. 需要进位的bit:   **unsigned**  (a&b)<<1; 注意这里用unsigned
2. 不考虑进位的和：a^b
3. 应该是这两个之和，但不能用加号，所以getsum(这两个)
4. 迭代的base case是所有的位都进过了

```c++
class Solution {
public:
    int getSum(int a, int b) {
    
        return b==0? a:getSum(a^b, (unsigned int)(a&b)<<1);
          
    }
};
```

### 12. 318, 字符串数组没公共字符的一对string长度的最大乘积Maximum Product of Word Lengths 

这题挺巧的。

对于每一个string，用一个整数（32位），0-26上表示'a' 到'z'有没有出现过（0：没有，1：有）

然后show[i]*show[j]==0即为没有公共字符

```c++
class Solution {
public:
    int maxProduct(vector<string>& words) {
        vector<int> show(words.size());
        int result=0;
        for(int i=0;i<words.size();i++)
            for(char c:words[i])
            {
                show[i] |= 1<<(c-'a');
            }
        for(int i=0;i<words.size();i++)
            for(int j=i;j<words.size();j++)
            {
                if((show[i]&show[j])==0 && words[i].size()*words[j].size()>result)
                    result=words[i].size()*words[j].size();
            }
        return result;

    }
};
```

### 13. 338 统计从 0 ~ n 每个数的二进制表示中 1 的个数 Counting Bits (Medium)

```c++
class Solution {
public:
    vector<int> countBits(int n) {
     vector<int> result(n+1);
        for(int i=0;i<=n;i++)
        {
            result[i]=count_one(i);
        }
        return result;
    }
    int count_one(int n)
    {
        int result = 0;
        while(n>0)
        {
            if((n&0x1)==1)
                result++;
            n=n>>1;
        }
        return result;
    }
};
```

